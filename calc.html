<script>

var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("").reduce(function(set,c){
	return set.add(c)
}, new Set());

var subRefrenceMap = {
	"e:2": 25,
	"ea:32": 30
}
var orderedOperationsGroups = [new Set(["/", "*"]), new Set(["+", "-"])];
var possibleOperations = orderedOperationsGroups.reduce(function(possibleOperations, operationGroup){
	operationGroup.forEach(function(operation){
		possibleOperations.add(operation);
	});

	return possibleOperations;
}, new Set());

var restrictedChars = Object.assign(possibleOperations, {});
restrictedChars.add("(").add(")").add(":");

var functionMap = {};

function evalString(str){
	return orderedOperationsGroups.reduce(function(acc, operationSet){
		return evalSymbol(acc, operationSet)
	}, str);
}

function isNumberOrPeriod(str){
	return str == "." || isNumber(str)
}

function isNumber(str){
	return !isNaN(parseInt(str));
}

function toString(number){
	var str = number.toString();

	
	return str;
}

function evalSymbol(str, operations){
	var stack = [];
	var i =0;

	while(i<str.length){
		var c = str[i];

		if(operations.has(c)){
			var operation = c;
			var right = "";

			i++;

			while(i<str.length){ // find right
				c = str[i];

				if(isNumberOrPeriod(c)){
					right += c;	
					i++;				
				}
				else {
					i--;
					break;
				}
			}

			var left = "";

			while(stack.length){
				if(isNumberOrPeriod(peek(stack))){
					left = stack.pop() + left;
				}
				else{
					break;
				}
			}

			if(operation == "*"){
				stack.push(toString(Number(left) * Number(right)));
			}
			else if(operation == "/"){
				stack.push(toString(Number(left) / Number(right)));
			}
			if(operation == "+"){
				stack.push(toString(Number(left) + Number(right)));
			}
			else if(operation == "-"){
				stack.push(toString(Number(left) - Number(right)));
			}

		}
		else{
			stack.push(c);
		}

		i++
	}

	return stack.join("")
}

function validate(str){ 
	var stack = [];

	for(var i=0; i<str.length; i++){
		if(str[i] == "("){
			stack.push(i);
		}
		else if(str[i] == ")"){
			if(stack.length){
				stack.pop();
			}
			else {
				var error = new Error(`Unexpected closing paren at position ${i}.`);
				error.postionData = i;
				error.type = "UnexpectedClosing";

				throw error;
			}
		}
	}

	if(stack.length){
		var error = new Error(`Unclosed parens for paren(s) opened in postion (s) ${stack.join(", ")}.`);

		error.postionData = stack;
		error.type = "UnclosedParen";

		throw error;
	}

}

function peek(stack){
	return stack.length ? stack[stack.length-1] : null;
}

function characterBelongsToFunction(c){
	return c != null && !restrictedChars.has(c) && !isNumber(parseInt);
}

function isLeftCharacterRefrence(c){
	//TODO optimze
	return characters.has(c);
}

function isRightCharacterRefrence(c){
	//TODO optimze
	return isNumber(c);
}

function resolveReference(refrenceKey){ //stub data
	return subRefrenceMap[refrenceKey.toLowerCase()];
}

function calc(str){
	validate(str)

	var retVal = 0;
	var i=0;
	var stack = [];

	while(i<str.length){
		var c = str[i];

		if(c == ":"){//resolve reference
			var left = "";
			var backTrackCount = 0;

			while(isLeftCharacterRefrence(peek(stack))){
				backTrackCount++;
				left = stack.pop() + left;
			}

			var right = "";
			i++;
			while(i<str.length){ // find right
				c = str[i];

				if(isRightCharacterRefrence(c)){
					right += c;	
					i++;				
				}
				else {
					i--;
					break;
				}
			}


			var refrenceKey = `${left}:${right}`
			if(!left || !right){
				var error = Error(`Invalid reference key ${refrenceKey}.`);
				error.type = "Invalid refrence.";
				error.refrenceKey = refrenceKey;
				error.postion = i-backTrackCount;
			}
			else {
				stack.push(resolveReference(refrenceKey));
			}
		}
		else if(c==")"){
			//found a close ....back track to the open
			var formula = "";
			var backTrackCount = 1;
			var popped = stack.pop();

			//find left and right and do it
			while(popped != "("){
				formula = popped + formula;
				popped = stack.pop();
				backTrackCount++
			}

			//back track to the function name
			var evaluationValue = evalString(formula);
			
			if(characterBelongsToFunction(peek(stack))){
				var functionToApply = "";
				while(characterBelongsToFunction(peek(stack))){
					backTrackCount++;
					functionToApply = stack.pop() + functionToApply;
				}

				if(functionMap.hasOwnProperty(functionToApply)){
					stack.push(functionMap[functionToApply](evaluationValue));
				}
				else {
					var error = Error(`Refrence to undefined function ${functionToApply} in ${str}.`);
					error.type = "UndefinedFunction";
					error.functionName = "foobar";
					error.postion = i-backTrackCount;

					throw error;
				}
			}
			else {
				stack.push(evaluationValue);
			}
		}
		else if(c != " ") {
			stack.push(c);
		}


		i++;
	}

	return new Number(evalString(stack.join("")));

}

var floor = function(number){
	return Math.floor(number);
}

functionMap["floor"] = floor;

//push chars from left to right on to a stack
//think of the ( as starts and stops

function resolveReferencesForTestCases(str){
	return Object.keys(subRefrenceMap).reduce(function(resolved, key){
		return resolved.replace(new RegExp(key, "g"), subRefrenceMap[key]);
	}, str)
}

var testCases = ["(5+10*2*2+3+(1*2))*(2+1)",
"((5+10*2*2+3+(1*2))*(2+1)+10.9*2)",
"(5+10*2*2+3+(1*2))*floor(2+1.33)",
"e:2+(5+10*2*2+3+(1*2))*floor(2+1.33 * (e:2))/ea:32"];


testCases.forEach(function(it){
	var expected = eval(resolveReferencesForTestCases(it));
	var actual = calc(it);
	
	console.log(expected == actual, expected, actual)
});

try {
	validate("(()()")
	console.log("Failed test. Expected exception for unclosed paren.")
}
catch(e){
	console.log("Should catch unclosed parens.", e.type == "UnclosedParen", e.postionData[0] == 0, e.postionData.length == 1);
}

try {
	validate("(()()))")
	console.log("Failed test. Expected exception for unexpected closing paren.")
}
catch(e){
	console.log("Should catch unexpected closing parens.", e.type == "UnexpectedClosing", e.postionData == 6);
}

try {
	calc("(5+10*2*2+3+(1*2))*foobar(2+1.33)");
	console.log("Failed test. Expected exception for undefined function.")
}
catch(e){
	console.log("Should catch undefined functions.", e.type == "UndefinedFunction", e.functionName == "foobar", e.postion == 19);
}


</script>
